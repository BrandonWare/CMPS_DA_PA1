<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 5 Programming Assignment</title>
<style>* { font-family: monospace; }</style>
<script>

// NOTE: You must implement the data structures using the no prototype approach.
//       This is what the book uses, so you can copy it.
//       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

// NOTE: Please review the following links regularly:
//       https://it.pointpark.edu/tutorials/arrays-vs-objects/
//       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
//       https://it.pointpark.edu/tutorials/implementation-vs-interface/



//------------------------------------//
// The binary and binary search trees //
//------------------------------------//
console.log("The binary and binary search trees");

function BinarySearchTree() {
  function Node(key) {
    this.key = key;
    this.left = null;
    this.right = null;
  }

  var root = null;

  function insertNode(node, newNode) {
    if (newNode.key < node.key) {
      if (node.left === null) node.left = newNode;
      else insertNode(node.left, newNode);
    } else {
      if (node.right === null) node.right = newNode;
      else insertNode(node.right, newNode);
    }
  }

  this.insert = function(key) {
    var newNode = new Node(key);
    if (root === null) root = newNode;
    else insertNode(root, newNode);
  };

  function searchNode(node, key) {
    if (node === null) return false;
    if (key < node.key) return searchNode(node.left, key);
    else if (key > node.key) return searchNode(node.right, key);
    else return true;
  }

  this.search = function(key) {
    return searchNode(root, key);
  };

  function inOrderTraverseNode(node, callback) {
    if (node !== null) {
      inOrderTraverseNode(node.left, callback);
      callback(node.key);
      inOrderTraverseNode(node.right, callback);
    }
  }

  this.inOrderTraverse = function(callback) {
    inOrderTraverseNode(root, callback);
  };

  function preOrderTraverseNode(node, callback) {
    if (node !== null) {
      callback(node.key);
      preOrderTraverseNode(node.left, callback);
      preOrderTraverseNode(node.right, callback);
    }
  }

  this.preOrderTraverse = function(callback) {
    preOrderTraverseNode(root, callback);
  };

  function postOrderTraverseNode(node, callback) {
    if (node !== null) {
      postOrderTraverseNode(node.left, callback);
      postOrderTraverseNode(node.right, callback);
      callback(node.key);
    }
  }

  this.postOrderTraverse = function(callback) {
    postOrderTraverseNode(root, callback);
  };

  function minNode(node) {
    if (node) {
      while (node && node.left !== null) {
        node = node.left;
      }
      return node.key;
    }
    return null;
  }

  this.min = function() {
    return minNode(root);
  };

  function maxNode(node) {
    if (node) {
      while (node && node.right !== null) {
        node = node.right;
      }
      return node.key;
    }
    return null;
  }

  this.max = function() {
    return maxNode(root);
  };

  function removeNode(node, key) {
    if (node === null) return null;
    if (key < node.key) {
      node.left = removeNode(node.left, key);
      return node;
    } else if (key > node.key) {
      node.right = removeNode(node.right, key);
      return node;
    } else {
      if (node.left === null && node.right === null) {
        node = null;
        return node;
      }
      if (node.left === null) {
        node = node.right;
        return node;
      } else if (node.right === null) {
        node = node.left;
        return node;
      }
      var aux = findMinNode(node.right);
      node.key = aux.key;
      node.right = removeNode(node.right, aux.key);
      return node;
    }
  }

  function findMinNode(node) {
    while (node && node.left !== null) node = node.left;
    return node;
  }

  this.remove = function(key) {
    root = removeNode(root, key);
  };

  this.print = function() {
    function print(node) {
      if (node !== null) {
        var leftChild = node.left !== null ? node.left.key : "None";
        var rightChild = node.right !== null ? node.right.key : "None";
        console.log(leftChild + " <-- " + node.key + " --> " + rightChild);
        print(node.left);
        print(node.right);
      }
    }
    console.log("===tree===");
    print(root);
    console.log("==========");
  };
}

// Build example tree
var tree = new BinarySearchTree();
tree.insert(11);
tree.insert(7);
tree.insert(15);
tree.insert(5);
tree.insert(9);
tree.insert(13);
tree.insert(20);
tree.insert(3);
tree.insert(6);
tree.insert(8);
tree.insert(10);
tree.insert(12);
tree.insert(14);
tree.insert(18);
tree.insert(25);
tree.insert(19);
tree.print();


//----------------//
// Tree traversal //
//----------------//
console.log("Tree traversal");

function printNode(value) {
  console.log(value);
}

console.log("In-order:");
tree.inOrderTraverse(printNode);

console.log("Pre-order:");
tree.preOrderTraverse(printNode);

console.log("Post-order:");
tree.postOrderTraverse(printNode);


//--------------------------------//
// Searching for values in a tree //
//--------------------------------//
console.log("Searching for values in a tree");
console.log("Min:", tree.min());
console.log("Max:", tree.max());
console.log("Search 19:", tree.search(19));
console.log("Search 100:", tree.search(100));



//--------------------------//
// Creating the Graph class //
//--------------------------//
console.log("Creating the Graph class");

function Graph() {
  var vertices = [];
  var adjList = new Map();

  this.addVertex = function(v) {
    vertices.push(v);
    adjList.set(v, []);
  };

  this.addEdge = function(v, w) {
    adjList.get(v).push(w);
    adjList.get(w).push(v);
  };

  this.printGraph = function() {
    vertices.forEach(function(v) {
      console.log(v + " -> " + adjList.get(v).join(", "));
    });
  };

  this.bfs = function(startingNode) {
    var visited = {};
    var q = [];
    visited[startingNode] = true;
    q.push(startingNode);

    while (q.length !== 0) {
      var getQueueElement = q.shift();
      console.log(getQueueElement);

      var getList = adjList.get(getQueueElement);
      for (var i in getList) {
        var neigh = getList[i];
        if (!visited[neigh]) {
          visited[neigh] = true;
          q.push(neigh);
        }
      }
    }
  };

  this.dfs = function(startingNode) {
    var visited = {};
    this.DFSUtil = function(v, visited) {
      visited[v] = true;
      console.log(v);
      var getNeighbours = adjList.get(v);
      for (var i in getNeighbours) {
        var n = getNeighbours[i];
        if (!visited[n]) this.DFSUtil(n, visited);
      }
    };
    this.DFSUtil(startingNode, visited);
  };
}

// Example from the book
var g = new Graph();
var vertices = ["A", "B", "C", "D", "E", "F"];
for (var i = 0; i < vertices.length; i++) g.addVertex(vertices[i]);
g.addEdge("A", "B");
g.addEdge("A", "D");
g.addEdge("A", "E");
g.addEdge("B", "C");
g.addEdge("D", "E");
g.addEdge("E", "F");
g.addEdge("E", "C");
g.addEdge("C", "F");

console.log("Graph adjacency list:");
g.printGraph();

console.log("BFS from A:");
g.bfs("A");

console.log("DFS from A:");
g.dfs("A");


//--------------------------//
// Shortest path algorithms //
//--------------------------//
console.log("Shortest path algorithms");

function dijkstra(graph, start) {
  var dist = {};
  var visited = {};
  var prev = {};
  var vertices = Array.from(graph.keys());

  vertices.forEach(v => {
    dist[v] = Infinity;
    visited[v] = false;
    prev[v] = null;
  });
  dist[start] = 0;

  for (var count = 0; count < vertices.length - 1; count++) {
    var u = null;
    var min = Infinity;
    vertices.forEach(v => {
      if (!visited[v] && dist[v] <= min) {
        min = dist[v];
        u = v;
      }
    });

    visited[u] = true;

    var neighbors = graph.get(u);
    for (var n in neighbors) {
      var pair = neighbors[n];
      var vertex = pair.vertex;
      var weight = pair.weight;
      if (!visited[vertex] && dist[u] + weight < dist[vertex]) {
        dist[vertex] = dist[u] + weight;
        prev[vertex] = u;
      }
    }
  }

  return { dist: dist, prev: prev };
}

// Weighted graph example
var weightedGraph = new Map();
weightedGraph.set("A", [{vertex:"B",weight:2},{vertex:"C",weight:4}]);
weightedGraph.set("B", [{vertex:"C",weight:1},{vertex:"D",weight:7}]);
weightedGraph.set("C", [{vertex:"E",weight:3}]);
weightedGraph.set("D", [{vertex:"F",weight:1}]);
weightedGraph.set("E", [{vertex:"D",weight:2},{vertex:"F",weight:5}]);
weightedGraph.set("F", []);

var shortest = dijkstra(weightedGraph, "A");
console.log("Dijkstra distances:", shortest.dist);
console.log("Previous vertices:", shortest.prev);

</script>
</head>
<body>
  See console!
</body>
</html>
